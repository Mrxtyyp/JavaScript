## What are the methods for creating objects?

Generally, objects are created in literal form. However, this method generates a large amount of duplicate code when creating a large number of similar objects. However, js is different from the general object-oriented language. Before ES6, it had no concept of class. However, functions can be used for simulation to generate Reusable Object creation methods. Common methods include the following:

1. The first is the factory mode. The main working principle of the factory mode is to encapsulate the details of creating objects with functions so as to achieve the purpose of reuse by calling functions. However, it has a big problem that the created object cannot be associated with a certain type. It simply encapsulates the reuse code without establishing the relationship between objects and types.

2. The second is the constructor mode. Each function in js can be used as a constructor. As long as a function is called through new, it can be called a constructor. Executing a constructor first creates an object, then points the prototype of the object to the prototype property of the constructor, then points this in the execution context to the object, and finally executes the entire function. If the return value is not an object, the newly created object is returned. Because the value of this points to the newly created object, you can use this to assign values to the object. The advantage of constructor mode over factory mode is that the created object is connected with the constructor, so the type of the object can be identified by prototype. However, a constructor has a disadvantage that it creates unnecessary function objects, because a function is also an object in js. Therefore, if an object attribute contains a function, a new function object is created each time, wasting unnecessary memory space, because functions are common to all instances.

3. The third mode is prototype mode, because each function has a prototype attribute, which is an object and contains attributes and methods that can be shared by all instances created by constructors. Therefore, you can use prototype objects to add common attributes and methods to reuse code. Compared with the constructor mode, this method solves the reuse problem of function objects. However, this mode also has some problems. One is that it cannot initialize the value by passing in parameters. The other is that if there is a value of a reference type such as Array, all instances will share an object. Changes to the value of the reference type by one instance will affect all instances.

4. The fourth mode is the combination of constructor mode and prototype mode, which is the most common way to create custom types. Because there are some problems in using the constructor mode and the prototype mode separately, the two modes can be combined to initialize the properties of the object through the constructor and reuse the function method through the prototype object. This method solves the disadvantage of using two modes alone, but one disadvantage is that the encapsulation of the code is not good enough because two different modes are used.

5. The fifth mode is the dynamic prototype mode, which moves the creation process of the prototype method assignment to the inside of the constructor. By judging whether the attribute exists, the effect of assigning the prototype object only once when the function is called for the first time can be realized. This method encapsulates the above mixed mode well.

6. The sixth mode is the parasitic constructor mode, which is basically the same as the implementation of the factory mode. My understanding of this mode is that it is mainly based on an existing type and extends the instantiated object during instantiation. In this way, the original constructor does not need to be modified, and the object is expanded. One of its disadvantages is the same as the factory mode, which cannot recognize objects.
